# ------------------------------------------------------------------------------------
#  Test Failure Detection (Composite Action)
#
#  Purpose: Define and provide reusable test failure detection functions for
#  robust test output parsing across different formats and test types.
#
#  This action provides sophisticated failure detection capabilities:
#    - JSON-based test output parsing (fast single-pass)
#    - Text-based failure detection with multiple patterns
#    - Detailed error capture and context preservation
#    - Fallback detection for edge cases
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: "Test Failure Detection"
description: "Provides robust test failure detection functions for JSON and text output parsing"

inputs:
  output-file:
    description: "Test output file to analyze"
    required: false
    default: "test-output.log"
  exit-code:
    description: "Test command exit code"
    required: false
    default: "0"
  mode:
    description: "Detection mode (json or text)"
    required: false
    default: "text"
  failures-file:
    description: "Output file for detected failures"
    required: false
    default: "test-failures.txt"

outputs:
  failure-count:
    description: "Number of detected test failures"
    value: ${{ steps.detect-failures.outputs.failure-count }}
  has-failures:
    description: "Boolean indicating if failures were detected"
    value: ${{ steps.detect-failures.outputs.has-failures }}
  detailed-failures-file:
    description: "Path to detailed failures file"
    value: ${{ steps.detect-failures.outputs.detailed-failures-file }}

runs:
  using: "composite"
  steps:
    - name: üîß Define failure detection functions
      shell: bash
      run: |
        # Define reusable function for robust test failure detection
        cat > test-failure-functions.sh << 'DETECTION_FUNCTIONS_EOF'
        #!/bin/bash

        # Robust test failure detection function
        detect_test_failures() {
          local output_file="$1"
          local exit_code="${2:-0}"
          local mode="${3:-text}"
          local failures_file="${4:-test-failures.txt}"

          echo "üîç Detecting test failures with exit code: $exit_code, mode: $mode"

          # Primary check: exit code indicates failure
          if [[ "$exit_code" -ne 0 ]]; then
            echo "‚ùå Exit code $exit_code indicates test failure"

            if [[ -f "$output_file" ]]; then
              case "$mode" in
                "json")
                  # Enhanced JSON-based detection
                  detect_failures_from_json "$output_file" "$failures_file"
                  ;;
                "text"|*)
                  # Enhanced text-based detection
                  detect_failures_from_text "$output_file" "$failures_file"
                  ;;
              esac

              # Count detected failures
              if [[ -f "$failures_file" ]]; then
                DETECTED_FAILURES=$(wc -l < "$failures_file" 2>/dev/null || echo "0")
                echo "üìä Detected $DETECTED_FAILURES specific failures"
                return $DETECTED_FAILURES
              fi
            else
              echo "‚ö†Ô∏è Output file '$output_file' not found, relying on exit code"
              echo "Exit code indicates failure but no output file found" > "$failures_file"
              return 1
            fi
          else
            echo "‚úÖ Exit code 0 indicates success"
            touch "$failures_file"  # Create empty failures file
            return 0
          fi
        }

        # Smart and efficient JSON failure detection
        detect_failures_from_json() {
          local json_file="$1"
          local failures_file="$2"

          echo "üîç Using smart JSON-based failure detection on $json_file"

          # Quick JSON validation (< 0.1s) - check if file contains JSON test output
          if ! grep -q '^{.*"Action"' "$json_file" 2>/dev/null; then
            echo "‚ö†Ô∏è No JSON content detected, using text fallback"
            detect_failures_from_text "$json_file" "$failures_file"
            return
          fi

          echo "‚úÖ JSON content detected, processing efficiently..."

          # Fast single-pass JSON extraction (< 1s for 10K lines)
          # Filter JSON lines and parse in one pass - eliminates 2-minute hang
          grep '^{' "$json_file" 2>/dev/null | \
            jq -r 'select(.Action == "fail") | "--- FAIL: \(.Test) (\(.Package))"' \
            2>/dev/null > "$failures_file"

          local failure_count
          failure_count=$(wc -l < "$failures_file" 2>/dev/null | tr -d '\n\r' | xargs)
          [[ "$failure_count" =~ ^[0-9]+$ ]] || failure_count=0

          # Only report actual failures from JSON Action=fail, not log messages
          if [[ "$failure_count" -gt 0 ]]; then
            echo "‚úÖ Found $failure_count test failures in JSON output"
            return 0
          else
            echo "‚ÑπÔ∏è No failures detected in JSON output"
            return 0
          fi
        }

        # Enhanced text-based failure detection
        detect_failures_from_text() {
          local text_file="$1"
          local failures_file="$2"
          local detailed_failures_file="${failures_file%.txt}-detailed.txt"

          echo "üîç Using enhanced text-based failure detection on $text_file"

          # Enhanced pattern matching for various failure formats
          # Patterns handle: FAIL, --- FAIL, --FAIL, [FAIL], FAIL:, etc.
          local patterns=(
            '^FAIL[[:space:]:]'
            '^---[[:space:]]*FAIL'
            '^--[[:space:]]*FAIL'
            '^\[?FAIL\]?[[:space:]:.]'
            '--- FAIL:'
            'FAIL[[:space:]]*:'
            '^[[:space:]]*FAIL[[:space:]]'
          )

          local temp_failures=$(mktemp)
          local temp_detailed=$(mktemp)
          local found_any=false

          # First pass: Find all failure lines and capture context
          for pattern in "${patterns[@]}"; do
            if grep -E -A 15 "$pattern" "$text_file" >> "$temp_detailed" 2>/dev/null; then
              found_any=true
              # Also capture just the failure line for the summary
              grep -E "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null || true
            fi
          done

          if [[ "$found_any" == "true" ]]; then
            # Process the detailed failures to create structured output
            echo "üîç Processing detailed failure output..."

            # Create a structured detailed failures file with error messages
            awk '
              BEGIN {
                current_test = ""
                capture_output = 0
                output_buffer = ""
              }
              /^(FAIL|---.*FAIL|--.*FAIL|\[?FAIL\]?)/ {
                # If we were capturing output, save it
                if (current_test != "" && output_buffer != "") {
                  print "TEST:" current_test
                  print "ERROR:" output_buffer
                  print "---SEPARATOR---"
                }

                # Start new test capture
                current_test = $0
                output_buffer = ""
                capture_output = 1
                next
              }
              capture_output == 1 && /^[[:space:]]*$/ {
                # Empty line might end the error context
                if (length(output_buffer) > 100) capture_output = 0
                next
              }
              capture_output == 1 && !/^(PASS|ok |FAIL|---.*FAIL|--.*FAIL)/ {
                # Capture error output lines
                if (output_buffer == "") {
                  output_buffer = $0
                } else {
                  output_buffer = output_buffer "\n" $0
                }
                # Stop if we have captured enough context
                if (length(output_buffer) > 1500) capture_output = 0
              }
              /^(PASS|ok )/ && capture_output == 1 {
                # Another test started, stop capturing
                capture_output = 0
              }
              END {
                # Save the last test if we were capturing
                if (current_test != "" && output_buffer != "") {
                  print "TEST:" current_test
                  print "ERROR:" output_buffer
                  print "---SEPARATOR---"
                }
              }
            ' "$temp_detailed" > "$detailed_failures_file" 2>/dev/null || true

            # Remove duplicates and sort for the summary file
            sort -u "$temp_failures" > "$failures_file"
            echo "‚úÖ Text parsing found $(wc -l < "$failures_file") unique failures with detailed error messages"

            # Clean up
            rm -f "$temp_failures" "$temp_detailed"
            return 0
          fi

          # Fallback: look for any error indicators
          echo "‚ö†Ô∏è Standard failure patterns not found, checking for error indicators"
          local error_patterns=(
            'panic:'
            'fatal error:'
            'build failed'
            'compilation error'
            'timeout'
            'killed'
            'error:'
          )

          for pattern in "${error_patterns[@]}"; do
            if grep -i -A 5 "$pattern" "$text_file" >> "$temp_detailed" 2>/dev/null; then
              found_any=true
              grep -i "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null || true
            fi
          done

          if [[ "$found_any" == "true" ]]; then
            sort -u "$temp_failures" > "$failures_file"
            cp "$temp_detailed" "$detailed_failures_file" 2>/dev/null || true
            echo "‚ö†Ô∏è Found $(wc -l < "$failures_file") error indicators (not standard test failures)"
            rm -f "$temp_failures" "$temp_detailed"
            return 0
          fi

          rm -f "$temp_failures" "$temp_detailed"

          # If exit code indicated failure but no patterns found, create generic entry
          if [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]]; then
            echo "Generic test failure (exit code ${TEST_EXIT_CODE:-0}) - pattern detection failed" > "$failures_file"
            echo "‚ö†Ô∏è Exit code indicates failure but no recognizable patterns found"
            return 1
          else
            touch "$failures_file"  # Create empty failures file
            echo "‚úÖ No failures detected and exit code is 0"
            return 0
          fi
        }

        # Utility function for safe numeric validation
        sanitize_numeric() {
          local value="$1"
          value=$(echo "$value" | tr -d '\n\r' | xargs)
          if [[ "$value" =~ ^[0-9]+$ ]]; then
            echo "$value"
          else
            echo "0"
          fi
        }

        # Export functions for use in other steps
        export -f detect_test_failures
        export -f detect_failures_from_json
        export -f detect_failures_from_text
        export -f sanitize_numeric
        DETECTION_FUNCTIONS_EOF

        # Source the functions to make them available
        source test-failure-functions.sh
        echo "‚úÖ Failure detection functions defined and loaded"

    - name: üîç Detect test failures
      id: detect-failures
      shell: bash
      run: |
        # Source the functions
        source test-failure-functions.sh

        # Run detection with provided inputs
        OUTPUT_FILE="${{ inputs.output-file }}"
        EXIT_CODE="${{ inputs.exit-code }}"
        MODE="${{ inputs.mode }}"
        FAILURES_FILE="${{ inputs.failures-file }}"

        # Detect failures
        detect_test_failures "$OUTPUT_FILE" "$EXIT_CODE" "$MODE" "$FAILURES_FILE"
        detection_result=$?

        # Calculate outputs
        if [[ -f "$FAILURES_FILE" ]]; then
          FAILURE_COUNT=$(wc -l < "$FAILURES_FILE" 2>/dev/null | tr -d '\n\r' | xargs)
          FAILURE_COUNT=$(sanitize_numeric "$FAILURE_COUNT")
        else
          FAILURE_COUNT=0
        fi

        HAS_FAILURES="false"
        if [[ "$FAILURE_COUNT" -gt 0 ]] || [[ "$detection_result" -ne 0 ]]; then
          HAS_FAILURES="true"
        fi

        DETAILED_FILE="${FAILURES_FILE%.txt}-detailed.txt"

        # Set outputs
        echo "failure-count=$FAILURE_COUNT" >> $GITHUB_OUTPUT
        echo "has-failures=$HAS_FAILURES" >> $GITHUB_OUTPUT
        echo "detailed-failures-file=$DETAILED_FILE" >> $GITHUB_OUTPUT

        echo "üìä Failure detection results:"
        echo "   ‚Ä¢ Failure count: $FAILURE_COUNT"
        echo "   ‚Ä¢ Has failures: $HAS_FAILURES"
        echo "   ‚Ä¢ Detailed file: $DETAILED_FILE"
