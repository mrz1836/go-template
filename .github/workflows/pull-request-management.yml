# ------------------------------------------------------------------------------------
#  Pull Request Management Workflow
#
#  Purpose: Automatically manages PR labels, assignments, and welcomes new contributors
#
#  Triggers: On pull request events (opened, reopened, ready for review)
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: pull-request-management

on:
  pull_request:
    types: [opened, reopened, ready_for_review]

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  DEFAULT_ASSIGNEE: mrz1836

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Apply labels based on branch prefix
  # ---------------------------------------------------------------------------
  apply-labels:
    name: Apply Branch-Based Labels
    runs-on: ubuntu-latest

    permissions:
      contents: read
      pull-requests: write

    if: |
      !contains(fromJSON('["dependabot[bot]", "mergify[bot]", "copilot[bot]"]'), github.event.pull_request.user.login)

    steps:
      - name: Apply labels based on branch prefix
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN }}
          script: |
            const branch = context.payload.pull_request.head.ref;
            const prNumber = context.payload.pull_request.number;

            // Define label mappings
            const labelRules = [
              { pattern: /^(bug)?fix\//i, labels: ['bug-P3'] },
              { pattern: /^chore\//i, labels: ['chore', 'update'] },
              { pattern: /^deps\//i, labels: ['chore', 'dependencies'] },
              { pattern: /^docs\//i, labels: ['documentation', 'update'] },
              { pattern: /^feat(ure)?\//i, labels: ['feature'] },
              { pattern: /^hotfix\//i, labels: ['hot-fix'] },
              { pattern: /^idea\//i, labels: ['idea'] },
              { pattern: /^proto(type)?\//i, labels: ['prototype', 'idea'] },
              { pattern: /^question\//i, labels: ['question'] },
              { pattern: /^refactor\//i, labels: ['refactor'] },
              { pattern: /^test\//i, labels: ['test'] },
            ];

            console.log(`Processing branch: ${branch}`);

            // Find matching labels
            const labelsToAdd = [];
            for (const rule of labelRules) {
              if (rule.pattern.test(branch)) {
                labelsToAdd.push(...rule.labels);
                console.log(`Matched pattern ${rule.pattern} -> adding labels: ${rule.labels.join(', ')}`);
              }
            }

            if (labelsToAdd.length === 0) {
              console.log('No branch patterns matched, skipping label application');
              return;
            }

            // Get existing labels to avoid duplicates
            try {
              const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });

              const existingLabelNames = existingLabels.map(label => label.name);
              const newLabels = labelsToAdd.filter(label => !existingLabelNames.includes(label));

              if (newLabels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: newLabels,
                });
                console.log(`‚úÖ Added labels: ${newLabels.join(', ')}`);
              } else {
                console.log('All labels already present, no changes needed');
              }
            } catch (error) {
              console.error(`‚ùå Failed to apply labels: ${error.message}`);
              // Don't fail the entire workflow for label issues
            }

  # ---------------------------------------------------------------------------
  # Job 2: Assign default assignee if needed
  # ---------------------------------------------------------------------------
  assign-default-assignee:
    name: Assign Default Assignee
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write

    if: |
      !contains(fromJSON('["dependabot[bot]", "mergify[bot]", "copilot[bot]"]'), github.event.pull_request.user.login) &&
      github.event.pull_request.head.repo.owner.login == github.repository_owner

    steps:
      - name: Assign default assignee if none assigned
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const assignees = pr.assignees || [];

            if (assignees.length > 0) {
              console.log(`PR already has ${assignees.length} assignee(s): ${assignees.map(a => a.login).join(', ')}`);
              console.log('Skipping default assignment');
              return;
            }

            try {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                assignees: [process.env.DEFAULT_ASSIGNEE],
              });

              console.log(`‚úÖ Assigned PR to ${process.env.DEFAULT_ASSIGNEE}`);

            } catch (error) {
              console.error(`‚ùå Failed to assign PR: ${error.message}`);
              // Don't fail the workflow for assignment issues
            }

  # ---------------------------------------------------------------------------
  # Job 3: Welcome new contributors
  # ---------------------------------------------------------------------------
  welcome-contributor:
    name: Welcome New Contributors
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write

    if: |
      github.event.action == 'opened' &&
      contains(fromJSON('["FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR"]'), github.event.pull_request.author_association) &&
      !contains(fromJSON('["dependabot[bot]", "mergify[bot]", "copilot[bot]"]'), github.event.pull_request.user.login) &&
      github.event.pull_request.head.repo.owner.login == github.repository_owner

    steps:
      - name: Welcome new contributor
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN }}
          script: |
            const author = context.payload.pull_request.user.login;
            const repoName = context.repo.repo;
            const repoOwner = context.repo.owner;

            const welcomeMessage = `## üëã Welcome, @${author}!

            Thank you for opening your first pull request in **${repoOwner}/${repoName}**!

            Here's what happens next:
            - ü§ñ Automated tests will run to check your changes
            - üëÄ A maintainer will review your contribution
            - üí¨ You might receive feedback or suggestions
            - ‚úÖ Once approved, your PR will be merged

            **Need help?** Feel free to ask questions in the comments below.

            Thanks for contributing to the project! üéâ`;

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: welcomeMessage,
              });

              console.log(`‚úÖ Posted welcome comment for new contributor @${author}`);

            } catch (error) {
              console.error(`‚ùå Failed to post welcome comment: ${error.message}`);
            }

  # ---------------------------------------------------------------------------
  # Job 4: PR size analysis
  # ---------------------------------------------------------------------------
  analyze-pr-size:
    name: Analyze PR Size
    runs-on: ubuntu-latest

    permissions:
      contents: read
      pull-requests: write
    if: github.event.action == 'opened'

    steps:
      - name: Add size label based on changes
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalChanges = additions + deletions;

            let sizeLabel = '';
            if (totalChanges <= 10) {
              sizeLabel = 'size/XS';
            } else if (totalChanges <= 50) {
              sizeLabel = 'size/S';
            } else if (totalChanges <= 200) {
              sizeLabel = 'size/M';
            } else if (totalChanges <= 500) {
              sizeLabel = 'size/L';
            } else {
              sizeLabel = 'size/XL';
            }

            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: [sizeLabel],
              });

              console.log(`‚úÖ Added size label: ${sizeLabel} (${totalChanges} changes)`);

            } catch (error) {
              console.error(`‚ùå Failed to add size label: ${error.message}`);
            }
